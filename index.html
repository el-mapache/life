<!DOCTYPE html>
<html>
  <head>
    <style>
      canvas {
        background: rgba(0,255,155,0.25);
      }

      .container {
        font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif; 
        display: table;
        margin-bottom: 20px;
      }

      .container h3 {
        font-weight: 300;
      }

      .container:before, .container:after {
        clear: both;
      }

      button {
        padding: 8px;
        outline: 0;
        background: #eeeeef;
        border: none;
        font-size: 23px;
        font-weight: 300;
        font-family: Helvetica;
        cursor: pointer;
        width: 80px;
        color: #333;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div style="float: left">
        <h3>Generations</h3>
        <span id="count">-</span>
      </div>
    
      <div style="float:left; margin-left: 20px;">
        <h3>Living Cells</h3>
        <span id="live-count">-</span>
      </div>
    </div>
    <div>
      <canvas id="board" height="401" width="801"></canvas>
    </div>
    <button type="button" id="play">Play</button>
    <button type="button" id="pause">Pause</button>
    <button type="button" id="reset">Reset</button>

    <script src="js/sample2d.js"></script>
    <script src="js/underscore.min.js"></script>
    <script>
      /*
       * complimentary color 255 - (initial r, g,b);
       * triad - inital r,g,b swap -> b,g,r; g,b,r; b,r,g, etc.
       *
      */

      var LIFE_STATES = {
        VIRGIN: 'virgin',
        ALIVE: 'alive',
        DEAD: 'dead'
      };

      function Cell(xPos, yPos) {
        this.liveTime = 0;
        this.currentState = LIFE_STATES.VIRGIN;
        this.previousState = LIFE_STATES.VIRGIN;
        this.x = xPos;
        this.y = yPos;
        this.history = [];
        //this.size;
      }


      var NUMBER_OF_SAMPLES = 850;

      var GAME_MODES = {
        CLASSIC: 'classic',
        ARCADE: 'arcade'
      };

      var game = {
        PLAYING: false,
        MODE: 'classic'
      };

      var gameInterval = undefined;

      var SQUARE_SIZE = 8;
      var TICK = 300;
      var counter = 0;
      var board = document.getElementById('board');
      var ctx = board.getContext('2d');
      var bounds = board.getBoundingClientRect();
      var grid = new Grid();

      var livingCellsEl = document.getElementById('live-count');
      var countEl = document.getElementById('count');

      var shouldEnd = 0;

      var shouldLive = [];
      var shouldDie = [];

      var width = board.width;
      var height = board.height;
      var unscaledWidth = (width - 1) / SQUARE_SIZE;
      var unscaledHeight = (height - 1) / SQUARE_SIZE;


      function Board(width, height) {
        var cells = [];
        var board = this;

        var row = column = -1;

        while (++row < height) {
          cells[row] = [];

          while (++column < width) {
            cells[row][column] = new Cell(column, row);
          }
          column = -1;
        }

        board.at = function(x, y) {
          if (cells[x]) {
            return cells[x][y];
          }
        };

        board.living = function() {
          return board.flatten(cells.map(function(cellGroup, i) {
            return board.filter(cellGroup, function(cell, i) {
              return cell.currentState === LIFE_STATES.VIRGIN;
            });
          }));
        };

        board.flatten = function(list/*...*/) {
          var output = [];

          board.each([].slice.call(arguments), function(list, listPos) {
            board.each(list, function(item, itemPos) {
              output[listPos * itemPos] = item;
            });
          });
          return output;
        };

        board.each = function(list, callback) {
          var length = list.length - 1;

          for (var i = 0; i < length; i++) {
            callback(list[i], i);
          }
        };

        board.filter = function(list, predicate) {
          var output = [];

          board.each(list, function(item, index) {
            if (predicate(item)) {
              output.push(item);
            }
          });

          return output;
        };
      }

      Board.constructor = Board;

      window.b = new Board(unscaledWidth, unscaledHeight);



      var SEED = [
        [1,1,1,0,1],
        [1,0,0,0,0],
        [0,0,0,1,1],
        [0,1,1,0,1],
        [1,0,1,0,1]
      ];

      var GLIDER = [
        [0,1,0],
        [0,0,1],
        [1,1,1]
      ];

      var BRICK = [
        [0,0,0,0,0,0,1,0],
        [0,0,0,0,1,0,1,1],
        [0,0,0,0,1,0,1,0],
        [0,0,0,0,1,0,0,0],
        [0,0,1,0,0,0,0,0],
        [0,1,1,0,0,0,0,0]
      ];

      // Defines a grid class with internal data structure to represent state at
      // a given position.
      function Grid() {
        var map = {};

        this.at = function(x,y) {
          return map[this._formatCoords(x,y)];
        };

        this.set = function(x,y,obj) {
          map[this._formatCoords(x,y)] = obj;
          return obj;
        };

        this.each = function(callback) {
          var position;
          for (position in map) {
            callback(map[position], position);
          }
        };

        this.filter = function(predicate) {
          var output = [];

          this.each(function(item, key) {
            if (predicate(item)) {
              output.push(key);
            }
          });

          return output;
        };

        this._formatCoords = function(x,y) {
          return x + 'x' + y;
        };
      }

      function inBounds(x,y) {
        return x > 0 && x <= unscaledWidth && y > 0 && y <= unscaledHeight;
      }

      function getNeighbors(x,y) {
        return [
          [x+1, y],
          [x-1, y],
          [x+1, y+1],
          [x-1, y-1],
          [x+1,y-1],
          [x-1,y+1],
          [x, y+1],
          [x, y-1],
        ];
      }

      function neighbors(x, y) {
        return getNeighbors(x, y).filter(function(neighbor) {
          return inBounds(neighbor[0], neighbor[1]) ? true : false;
        });
      }
      
      function doLife(x, y) {
        var thisLife = grid.at(x,y);

        var coordsList = [x, y];
        if (!thisLife) {
          shouldLive.push(coordsList);
        } else {
          shouldDie.push(coordsList);
        }
      }

      function reColor(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect((x * SQUARE_SIZE) - SQUARE_SIZE, (y * SQUARE_SIZE) - SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
      }

      function kill(x,y) {
        if (game.MODE === GAME_MODES.CLASSIC) {
          ctx.fillStyle = 'white';
        } else {
          if (grid.at(x,y)) {
            ctx.fillStyle = "rgba(235,245,255,0.8)";
          } else {
            ctx.fillStyle = "rgba(255,155,0,0.12)";
          }
        }

        ctx.fillRect((x * SQUARE_SIZE) - SQUARE_SIZE, (y * SQUARE_SIZE) - SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
        grid.set(x, y, 0);
      }

      function birth(x, y) {
        if (game.MODE === GAME_MODES.CLASSIC) {
          ctx.fillStyle = 'black';
        } else {
          ctx.fillStyle = "rgba(0,100,255,0.50)";
        }

        ctx.fillRect((x * SQUARE_SIZE) - SQUARE_SIZE, (y * SQUARE_SIZE) - SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
        grid.set(x, y, 1);
      }

      board.onclick = function(event) {
        var x = event.clientX - bounds.left;
        var y = event.clientY - bounds.top;


        addSquare(x, y);
      };

      function addSquare(x,y) {
        var col = ((x/SQUARE_SIZE) | 0) + 1;
        var row = ((y/SQUARE_SIZE) | 0) + 1;

        if (grid.at(col,row)) {
          kill(col,row);
        } else {
          birth(col,row);
        }
      }

      function play() {
        game.PLAYING = !game.PLAYING;
        var currentCellCount = grid.filter(function(item) { return item;}).length;

        grid.each(function(state, coordString) {
          var coords = coordString.split('x'); 
          var x = +coords[0], y = +coords[1];

          neighborCount = neighbors(x,y).filter(function(coordList) {
            var xx = +coordList[0], yy = +coordList[1];

            return grid.at(xx, yy) ? true : false;
          }).length;
          
          if (neighborCount > 1 && neighborCount <= 3) {
            if (game.MODE === GAME_MODES.ARCADE) {
              reColor(x,y, "rgba(255, 0, 100, 0.20)");
            }

            if (neighborCount === 3) {
              shouldLive.push([x,y]);
            }
          } else if (neighborCount >= 4 || neighborCount <= 1) {
            shouldDie.push([x,y]);
          }
        });

        var toKill;
        while (shouldDie.length) {
          toKill = shouldDie.pop();

          kill(toKill[0], toKill[1]);
        }

        var toBirth;
        while (shouldLive.length) {
          toBirth = shouldLive.pop();

          birth(toBirth[0], toBirth[1]);
        }

        shouldDie.length = 0;
        shouldLive.length = 0;
        counter += 1;


        var newCellCount = grid.filter(function(item) { return item; }).length;

        if (newCellCount === currentCellCount) {
          shouldEnd++;
        } else {
          shouldEnd = 0;
        }

        if (shouldEnd >= 8) {
          alert('Game Over');
          clearInterval(gameInterval);
          return;
        }

        livingCellsEl.innerHTML = newCellCount;
        countEl.innerHTML = counter;
      }


     // function showGrid() {
     //   ctx.beginPath();

     //   for (var x = 0; x < width; x += SQUARE_SIZE) {
     //     ctx.moveTo(x+0.5, 0);
     //     ctx.lineTo(x + 0.5, height);
     //   }

     //   for (var x = 0; x < height; x += SQUARE_SIZE) {
     //     ctx.moveTo(0, x + 0.5);
     //     ctx.lineTo(width, x + 0.5);
     //   }

     //   ctx.lineWidth = 1;
     //   ctx.stroke();
     // }

     // showGrid();

      for (var x = 1; x < width/SQUARE_SIZE;x++) {
        for (var y = 1; y < width/SQUARE_SIZE;y++) {
          grid.set(x,y,0);
        }
      }

      function resetBoard() {
        if (game.PLAYING) {
          clearInterval(gameInterval);
          game.PLAYING = !game.PLAYING;
          gameInterval = undefined;
          shouldLive.length = 0;
          shouldDie.length = 0;
          ctx.clearRect(0,0,width,height);
        }

        var samples = hilbertSampler(NUMBER_OF_SAMPLES );

        samples.forEach(function(sample) {
          var x = (sample[0] * width) | 0;
          var y = (sample[1] * height) | 0;
          
          if (x > width) {
            x =width;
          } else if (x < 0) {
            x = 0;
          }

          if (y > height) {
            y = height;
          } else if (y < 0) {
            y = 0;
          }
          addSquare(x,y);
        });
      }

      resetBoard(NUMBER_OF_SAMPLES);

      document.getElementById('play').onclick = function() {
        play();
        gameInterval = setInterval(play, TICK);
      }
      document.getElementById('reset').onclick = resetBoard;
    </script>
  </body>
</html>
