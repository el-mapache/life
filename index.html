<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="css/style.css"/>
  </head>
  <body>
    <div id="app-container">

      <div class="container">

        <div style="float: left">
          <h3>Generations</h3>
          <span id="generations"></span>
        </div>

        <div style="float:left; margin-left: 20px;">
          <h3>Living Cells</h3>
          <span id="living-cells"></span>
        </div>

      </div>


      <div>
        <canvas id='overlay' height="401" width="801"></canvas>
        <canvas id="board" height="400" width="800"></canvas>
      </div>

      <div>
        <button type="button" id="play">Play</button>
        <button type="button" id="pause">Pause</button>
        <button type="button" id="reset">Reset</button>
        <button type="button" id="grid-toggle">Grid</button>
        <button type="button" id="clear">Clear</button>
      </div>

    </div>

    <script src="js/sample2d.js"></script>
    <script src="js/underscore.min.js"></script>
    <script src="js/exoskeleton.min.js"></script>

    <script>


      /*
       * complimentary color 255 - (initial r, g,b);
       * triad - inital r,g,b swap -> b,g,r; g,b,r; b,r,g, etc.
       *
      */

      var LIFE_STATES = {
        PRISTINE: 'pristine',
        ALIVE: 'alive',
        DEAD: 'dead'
      };

      var GAME_MODES = {
        CLASSIC: 'classic',
        ARCADE: 'arcade'
      };


      var SQUARE_SIZE = 8;
      var bounds = document.getElementById('overlay').getBoundingClientRect();

      var shouldEnd = 0;



      var RulesService = {

      };

      var gameService = new (Backbone.Model.extend({
        defaults: {
          tickSpeed: 300,
          mode: 'classic',
          playing: false,
          livingCells: 0,
          lastLivingCells: 0,
          generations: 0,
          stagnationThreshold: 5,
          stagnant: false,
          stagnantGenerations: 0
        },

        updateLivingCells: function(count) {
          this.set({
            lastLivingCells: this.get('livingCells'),
            livingCells: count
          });

          if (this.get('livingCells') === this.get('lastLivingCells')) {
            this.set('stagnantGenerations', this.get('stagnantGenerations') + 1);
          } else {
            this.set('stagnantGenerations', this.get('stagnantGenerations') - 1);
          }

          if (this.get('stagnantGenerations') >= this.get('stagnationThreshold')) {
            this.set('stagnant', true);
          }
        },

        updateGeneration: function() {
          this.set('generations', this.get('generations') + 1);
        }
      }))();


      /** DATA MODELSish **/


      function Location(x,y) {
        this.x = x;
        this.y = y;
      }

      // Represents a single unit in the game.
      function Cell(initialXPos, initialYPos, size) {
        this.liveTime = 0;
        this.currentState = LIFE_STATES.PRISTINE;
        this.previousState = LIFE_STATES.PRISTINE;
        this.size = size;
        this.willLive = false;
        this.willDie = false;

        this.location = new Location(initialXPos, initialYPos);
        this.history = [];
      }

      Cell.prototype.setState = function(state) {
        var currentState = this.getState();

        this.previousState = currentState;
        this.history.push(this.previousState);
        this.currentState = state;

        return this;
      };

      // Pass in the drawing context and let the cell render itself to it.
      Cell.prototype.draw = function(ctx) {
        var size = this.size;
        var location = this.location;

        ctx.fillStyle = this.isAlive() ? "black" : "white";
        ctx.fillRect((location.x * size) - size, (location.y * size) - size, size, size);
      };

      Cell.prototype.getState = function() {
        return this.currentState;
      };

      Cell.prototype.isAlive = function() {
        return this.currentState === LIFE_STATES.ALIVE;
      };

      Cell.prototype.isDead = function() {
        return this.currentState === LIFE_STATES.DEAD;
      };

      Cell.prototype.isPristine = function() {
        return this.currentState === LIFE_STATES.PRISTINE;
      };

      Cell.constructor = Cell;



      function Board(width, height) {
        var TILE_SIZE = 8;

        this.cells = [];
        this.width = width/TILE_SIZE;
        this.height = height/TILE_SIZE;

        for (var y = 0; y < this.height; y++) {
          for (var x = 0; x < this.width; x++) {
            this.cells.push(new Cell(x, y, TILE_SIZE));
          }
        }
      }

      Board.prototype.inBounds = function(x, y) {
        return x > 0 && x <= (this.width - 1) &&
               y > 0 && y <= (this.height - 1);
      };

      Board.prototype.at = function(x,y) {
        return this.cells[x + this.width * y];
      };

      Board.prototype.filterBy = function(state) {
        return _.filter(this.cells, function(cell) {
          return cell.getState() === state;
        });
      };

      Board.prototype.each = function(callback) {
        _.each(this.cells, callback);
      };

      Board.prototype.neighborsOf = function(cell) {
        var neighborCoords = Board.neighbors(cell.location.x, cell.location.y);
        var board = this;

        return _.compact(neighborCoords.map(function(coords) {
          var x = coords[0];
          var y = coords[1];

          if (board.inBounds(x, y)) {
            return board.at(x, y);
          }
        }));
      };

      Board.neighbors = function(x, y) {
        return [
          [x + 1, y],
          [x - 1, y],
          [x, y + 1],
          [x, y - 1],
          [x + 1, y + 1],
          [x - 1, y - 1],
          [x + 1, y - 1],
          [x - 1, y + 1],
        ];
      };

      Board.constructor = Board;


      /** VIEWS **/

      var OverlayView = Backbone.View.extend({
        el: '#overlay',

        initialize: function() {
          this.model = new Backbone.Model({
            strokeStyle: '#333',
            lineWidth: 1,
            globalAlpha: 0
          });

          this.listenTo(this.model, 'change:globalAlpha', this.render.bind(this));
        },

        render: function() {
          var ctx = this.el.getContext('2d');

          var model = this.model.toJSON();

          ctx.clearRect(0, 0, this.el.width, this.el.height);
          ctx.beginPath();

          for (var x = 0; x < this.el.width; x += SQUARE_SIZE) {
            ctx.moveTo(x+0.5, 0);
            ctx.lineTo(x + 0.5, this.el.height);
          }

          for (var x = 0; x < this.el.height; x += SQUARE_SIZE) {
            ctx.moveTo(0, x + 0.5);
            ctx.lineTo(this.el.width, x + 0.5);
          }

           ctx.lineWidth   = model.lineWidth;
           ctx.strokeStyle = model.strokeStyle;
           ctx.globalAlpha = model.globalAlpha;
           ctx.stroke();
        },

        toggleGrid: function(payload) {
          this.model.set('globalAlpha', (payload.active ? 1.0 : 0.0));
        }
      });

      var GameStatsView = Backbone.View.extend({
        el: '#game-stats',

        initialize: function() {
          this.generationView = new BoundView({
            el: '#generations',
            boundProp: 'generations'
          }).render();

          this.livingCellCountView = new BoundView({
            el: '#living-cells',
            boundProp: 'livingCells'
          }).render();
        }
      });

      // A view bound to a single data attribute that changes over time.
      var BoundView = Backbone.View.extend({
        template: _.template('<%= data %>'),

        initialize: function(options) {
          this.boundProp = options.boundProp;
          this.listenTo(gameService, 'change:' + options.boundProp, this.render);
        },

        render: function() {
          this.el.innerHTML = this.template({data: gameService.get(this.boundProp)});
          return this;
        }
      });

      var ButtonView = Backbone.View.extend({
        events: {
          'click': 'onClick'
        },

        initialize: function(options) {
          this.model = new Backbone.Model({
            active: false
          });

          this.callback = options.callback;
          this.listenTo(this.model, 'change:active', this.updateClass);
          _.bindAll(this, 'updateClass');
        },

        updateClass: function(model, value) {
          if (value) {
            this.el.className = this.el.className + ' active';
          } else {
            this.el.className = this.el.className.replace('active', '');
          }
        },

        onClick: function(event) {
          this.model.set('active', !this.model.get('active'));
          this.callback(event, this.model.toJSON());
        }
      });


      var BoardView = Backbone.View.extend({
        el: '#board',

        initialize: function() {
          this.model = new Board(this.el.width, this.el.height);
          this.seedService = SamplerService;
          this.ctx = this.el.getContext('2d');
          this.runInterval = null;

          this.listenTo(gameService, 'change:playing', this._maybeStopPlay);
          this.listenTo(gameService, 'change:stagnant', this._maybeEndGame);

          _.bindAll(this, '_processSampledPoint', 'run', '_setNextCellState', '_maybeStopPlay', '_maybeEndGame');
          this._seed(100);
        },

        _maybeEndGame: function(model, value) {
          if (!value) {
            return;
          }

          this._stopPlayLoop();
          alert('GameOver!');
        },

        _maybeStopPlay: function(model, value) {
          if (value) {
            this.runInterval = setInterval(this.run, gameService.get('tickSpeed'));
          } else {
            this._stopPlayLoop();
          }
        },

        _stopPlayLoop: function() {

          if (this.runInterval) {
            clearInterval(this.runInterval);
            this.runInterval = null;
          }
        },

        _setNextCellState: function(cell) {
          var neighbors = _.size(_.filter(this.model.neighborsOf(cell), function(cell) {
            return cell.isAlive();
          }));

          if (neighbors < 2 || neighbors > 3) {
            cell.willDie = true;
          } else if (neighbors === 3) {
            cell.willLive = true;
          }
        },

        run: function() {
          this.model.each(this._setNextCellState);

          var ctx = this.ctx;

          this.model.each(function(cell) {
            if (!cell.willLive && !cell.willDie) {
              return;
            }

            cell.setState((cell.willLive ? LIFE_STATES.ALIVE : LIFE_STATES.DEAD));
            cell.draw(ctx);
            cell.willLive = false;
            cell.willDie = false;
          });

          gameService.updateLivingCells(_.size(this.model.filterBy(LIFE_STATES.ALIVE)));
          gameService.updateGeneration();
        },

        _seed: function(numberOfSamples) {
          var points = this.seedService.sample(numberOfSamples);

          gameService.set('livingCells', points.length);

          _.each(points, this._processSampledPoint);
        },

        _processSampledPoint: function(point) {
          this.setCellAtPoint(this._scalePoint(point));
        },

        _scalePoint: function(point) {
          return [
            (point[0] * this.model.width + 1) | 0,
            (point[1] * this.model.height + 1) | 0
          ];
        },

        setCellAtPoint: function(point) {
          var cell = this.model.at(point[0], point[1]);

          if (cell) {
            cell.setState(LIFE_STATES.ALIVE);
            cell.draw(this.ctx);
          }
        }
      });


      /** VIEW CONTROLLERS **/

      var AppViewController = Backbone.View.extend({
        el: '#app-container',

        events: {
          'click #overlay': 'toggleCell'
        },

        initialize: function() {
          _.bindAll(this, 'togglePlay', 'toggleGrid', 'pause');

          this.statsView = new GameStatsView();

          this.playButton = new ButtonView({
            el: '#play',
            callback: this.togglePlay
          });

          this.resetButton = new ButtonView({
            el: '#reset',
            callback: this.reset
          });

          this.gridButton = new ButtonView({
            el: '#grid-toggle',
            callback: this.toggleGrid
          });

          this.pauseButton = new ButtonView({
            el: '#pause',
            callback: this.pause
          });

          this.overlayView = new OverlayView();
          this.boardView = new BoardView();
        },

        togglePlay: function(event, payload) {
          gameService.set('playing', true);
        },

        reset: function(event, payload) {
          console.log('clicked reset');
        },

        pause: function(event, payload) {
          if (gameService.get('playing')) {
            gameService.set('playing', false);
          }
        },

        toggleGrid: function(event, payload) {
          this.overlayView.toggleGrid(payload);
        },

        toggleCell: function(event) {
          var x = (((event.clientX - bounds.left) / SQUARE_SIZE) | 0) + 1;
          var y = (((event.clientY - bounds.top) / SQUARE_SIZE) | 0) - 1;

          this.boardView.setCellAtPoint([x, y]);
        }
      });

      new AppViewController();


      var SEED = [
        [1,1,1,0,1],
        [1,0,0,0,0],
        [0,0,0,1,1],
        [0,1,1,0,1],
        [1,0,1,0,1]
      ];

      var GLIDER = [
        [0,1,0],
        [0,0,1],
        [1,1,1]
      ];

      var BRICK = [
        [0,0,0,0,0,0,1,0],
        [0,0,0,0,1,0,1,1],
        [0,0,0,0,1,0,1,0],
        [0,0,0,0,1,0,0,0],
        [0,0,1,0,0,0,0,0],
        [0,1,1,0,0,0,0,0]
      ];

      function doLife(x, y) {
        var thisLife = grid.at(x,y);

        var coordsList = [x, y];
        if (!thisLife) {
          shouldLive.push(coordsList);
        } else {
          shouldDie.push(coordsList);
        }
      }

      function reColor(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect((x * SQUARE_SIZE) - SQUARE_SIZE, (y * SQUARE_SIZE) - SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
      }

      function kill(x,y) {
        if (game.MODE === GAME_MODES.CLASSIC) {
          ctx.fillStyle = 'white';
        } else {
          if (grid.at(x,y)) {
            ctx.fillStyle = "rgba(235,245,255,0.8)";
          } else {
            ctx.fillStyle = "rgba(255,155,0,0.12)";
          }
        }

        ctx.fillRect((x * SQUARE_SIZE) - SQUARE_SIZE, (y * SQUARE_SIZE) - SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
        grid.set(x, y, 0);
      }

      function birth(x, y) {
        if (game.MODE === GAME_MODES.CLASSIC) {
          ctx.fillStyle = 'black';
        } else {
          ctx.fillStyle = "rgba(0,100,255,0.50)";
        }

        ctx.fillRect((x * SQUARE_SIZE) - SQUARE_SIZE, (y * SQUARE_SIZE) - SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
        grid.set(x, y, 1);
      }
    </script>
  </body>
</html>
