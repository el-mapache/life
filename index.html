<!DOCTYPE html>
<html>
  <head>
    <style>
      canvas {
        /*background: rgba(0,255,155,0.25);*/
      }

      .container {
        font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
        display: table;
        margin-bottom: 20px;
      }

      .container h3 {
        font-weight: 300;
      }

      .container:before, .container:after {
        clear: both;
      }

      button {
        padding: 8px;
        outline: 0;
        background: #eeeeef;
        border: none;
        font-size: 23px;
        font-weight: 300;
        font-family: Helvetica;
        cursor: pointer;
        width: 80px;
        color: #333;
      }

      #overlay {
        background: transparent;
        position: absolute;
      }
    </style>
  </head>
  <body>
    <div id="app-container">
      <div class="container">
        <div style="float: left">
          <h3>Generations</h3>
          <span id="count">-</span>
        </div>

        <div style="float:left; margin-left: 20px;">
          <h3>Living Cells</h3>
          <span id="live-count">-</span>
        </div>
      </div>
      <div>
        <canvas id='overlay' height="401" width="801"></canvas>
        <canvas id="board" height="400" width="800"></canvas>
      </div>
      <button type="button" id="play">Play</button>
      <button type="button" id="pause">Pause</button>
      <button type="button" id="reset">Reset</button>
      <button type="button" id="grid-toggle">Grid</button>
    </div>

    <script src="js/sample2d.js"></script>
    <script src="js/underscore.min.js"></script>
    <script src="js/exoskeleton.min.js"></script>

    <script>


      /*
       * complimentary color 255 - (initial r, g,b);
       * triad - inital r,g,b swap -> b,g,r; g,b,r; b,r,g, etc.
       *
      */

      var LIFE_STATES = {
        VIRGIN: 'virgin',
        ALIVE: 'alive',
        DEAD: 'dead'
      };

      var NUMBER_OF_SAMPLES =   50;

      var GAME_MODES = {
        CLASSIC: 'classic',
        ARCADE: 'arcade'
      };

      var game = {
        PLAYING: false,
        MODE: 'classic'
      };

      var gameInterval = undefined;

      var SQUARE_SIZE = 8;
      var TICK = 300;
      var counter = 0;
      var board = document.getElementById('board');
      var ctx = board.getContext('2d');
      var bounds = document.getElementById('overlay').getBoundingClientRect();
      var grid = new Grid();

      var livingCellsEl = document.getElementById('live-count');
      var countEl = document.getElementById('count');

      var shouldEnd = 0;

      var shouldLive = [];
      var shouldDie = [];

      var width = board.width;
      var height = board.height;
      var unscaledWidth = (width - 1) / SQUARE_SIZE;
      var unscaledHeight = (height - 1) / SQUARE_SIZE;


      /** DATA MODELSish **/

      function Location(x,y) {
        this.x = x;
        this.y = y;
      }

      // Represents a single unit in the game.
      function Cell(initialXPos, initialYPos, size) {
        this.liveTime = 0;
        this.currentState = LIFE_STATES.VIRGIN;
        this.previousState = LIFE_STATES.VIRGIN;
        this.size = size;

        this.location = new Location(initialXPos, initialYPos);
        this.history = [];
      }

      Cell.prototype.setState = function(state) {
        // Don't set a state if it isnt new.
        if (this.currentState === state) {
          return this;
        }

        this.previousState = this.currentState;
        this.history.push(this.previousState);
        this.currentState = state;

        return this;
      };

      // Pass in the drawing context and let the cell render itself to it.
      Cell.prototype.draw = function(ctx) {
        var size = this.size;
        var location = this.location;

        ctx.fillStyle = this.currentState === LIFE_STATES.ALIVE ? "black" : "white";
        ctx.fillRect((location.x * size) - size, (location.y * size) - size, size, size);
      };

      Cell.constructor = Cell;



      function Board(width, height) {
        var TILE_SIZE = 8;

        this.cells = [];
        this.width = width/TILE_SIZE;
        this.height = height/TILE_SIZE;

        for (var y = 0; y < this.height; y++) {
          for (var x = 0; x < this.width; x++) {
            this.cells.push(new Cell(x, y, TILE_SIZE));
          }
        }
      }

      Board.prototype.inBounds = function(x, y) {
        return x > 0 && x <= (this.width - 1) &&
               y > 0 && y <= (this.height - 1);
      };

      Board.prototype.at = function(x,y) {
        return this.cells[x + this.width * y];
      };

      Board.prototype.allByState = function(state) {
        return _.filter(this.cells, function(cell) {
          return cell.currentState === state;
        });
      };

      Board.constructor = Board;


      /** VIEWS **/

      var OverlayView = Backbone.View.extend({
        el: '#overlay',

        initialize: function() {
          this.model = new Backbone.Model({
            strokeStyle: '#ccc',
            lineWidth: 1,
            globalAlpha: 0
          });

          this.listenTo(this.model, 'change:globalAlpha', this.render.bind(this));
        },

        render: function() {
          var ctx = this.el.getContext('2d');

          var model = this.model.toJSON();

          ctx.clearRect(0, 0, this.el.width, this.el.height);
          ctx.beginPath();

          for (var x = 0; x < this.el.width; x += SQUARE_SIZE) {
            ctx.moveTo(x+0.5, 0);
            ctx.lineTo(x + 0.5, this.el.height);
          }

          for (var x = 0; x < this.el.height; x += SQUARE_SIZE) {
            ctx.moveTo(0, x + 0.5);
            ctx.lineTo(this.el.width, x + 0.5);
          }

           ctx.lineWidth   = model.lineWidth;
           ctx.strokeStyle = model.strokeStyle;
           ctx.globalAlpha = model.globalAlpha;
           ctx.stroke();
        }
      });

      var ButtonView = Backbone.View.extend({
        events: {
          'click': 'onClick'
        },

        initialize: function(options) {
          this.model = new Backbone.Model({
            active: false
          });

          this.callback = options.callback;
        },

        render: function() {

        },

        onClick: function(event) {
          this.model.set('active', !this.model.get('active'));
          this.callback(event, this.model.toJSON());
        }
      });


      var BoardView = Backbone.View.extend({
        el: '#board',

        initialize: function() {
          this.model = new Board(this.el.width, this.el.height);
          this.seedService = SamplerService;
          this.ctx = this.el.getContext('2d');

          _.bindAll(this, '_processSampledPoint');
          this._seed();
        },

        render: function() {},

        _seed: function() {
          var points = this.seedService.sample(NUMBER_OF_SAMPLES);

          _.each(points, this._processSampledPoint);
        },

        _processSampledPoint: function(point) {
          this.setCellAtPoint(this._scalePoint(point));
        },

        _scalePoint: function(point) {
          return [
            (point[0] * this.model.width+1) | 0,
            (point[1] * this.model.height+1) | 0
          ];
        },

        setCellAtPoint: function(point) {
          var cell = this.model.at(point[0], point[1]);

          if (cell) {
            cell.setState(LIFE_STATES.ALIVE);
            cell.draw(this.ctx);
          }
        }
      });


      /** VIEW CONTROLLERS **/

      var AppViewController = Backbone.View.extend({
        el: '#app-container',

        events: {
          'click #overlay': 'toggleCell'
        },

        initialize: function() {
          this.playButton = new ButtonView({
            el: '#play',
            callback: this.togglePlay
          });

          this.resetButton = new ButtonView({
            el: '#reset',
            callback: this.reset
          });

          this.gridButton = new ButtonView({
            el: '#grid-toggle',
            callback: this.toggleGrid.bind(this)
          });

          this.overlayView = new OverlayView();
          this.boardView = new BoardView();
        },

        togglePlay: function(event, payload) {
          console.log('clicked play');
        },

        reset: function(event, payload) {
          console.log('clicked reset');
        },

        toggleGrid: function(event, payload) {
          this.overlayView.model.set('globalAlpha', (payload.active ? 1.0 : 0.0));
        },

        toggleCell: function(event) {
          var x = ((event.clientX - bounds.left) / SQUARE_SIZE) | 0;
          var y = ((event.clientY - bounds.top) / SQUARE_SIZE) | 0;
console.log(event)
          this.boardView.setCellAtPoint([x,y]);
        }
      });

      new AppViewController();




      var SEED = [
        [1,1,1,0,1],
        [1,0,0,0,0],
        [0,0,0,1,1],
        [0,1,1,0,1],
        [1,0,1,0,1]
      ];

      var GLIDER = [
        [0,1,0],
        [0,0,1],
        [1,1,1]
      ];

      var BRICK = [
        [0,0,0,0,0,0,1,0],
        [0,0,0,0,1,0,1,1],
        [0,0,0,0,1,0,1,0],
        [0,0,0,0,1,0,0,0],
        [0,0,1,0,0,0,0,0],
        [0,1,1,0,0,0,0,0]
      ];

      // Defines a grid class with internal data structure to represent state at
      // a given position.
      function Grid() {
        var map = {};

        this.at = function(x,y) {
          return map[this._formatCoords(x,y)];
        };

        this.set = function(x,y,obj) {
          map[this._formatCoords(x,y)] = obj;
          return obj;
        };

        this.each = function(callback) {
          var position;
          for (position in map) {
            callback(map[position], position);
          }
        };

        this.filter = function(predicate) {
          var output = [];

          this.each(function(item, key) {
            if (predicate(item)) {
              output.push(key);
            }
          });

          return output;
        };

        this._formatCoords = function(x,y) {
          return x + 'x' + y;
        };
      }

      function inBounds(x,y) {
        return x > 0 && x <= unscaledWidth && y > 0 && y <= unscaledHeight;
      }

      function getNeighbors(x,y) {
        return [
          [x+1, y],
          [x-1, y],
          [x+1, y+1],
          [x-1, y-1],
          [x+1,y-1],
          [x-1,y+1],
          [x, y+1],
          [x, y-1],
        ];
      }

      function neighbors(x, y) {
        return getNeighbors(x, y).filter(function(neighbor) {
          return inBounds(neighbor[0], neighbor[1]) ? true : false;
        });
      }

      function doLife(x, y) {
        var thisLife = grid.at(x,y);

        var coordsList = [x, y];
        if (!thisLife) {
          shouldLive.push(coordsList);
        } else {
          shouldDie.push(coordsList);
        }
      }

      function reColor(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect((x * SQUARE_SIZE) - SQUARE_SIZE, (y * SQUARE_SIZE) - SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
      }

      function kill(x,y) {
        if (game.MODE === GAME_MODES.CLASSIC) {
          ctx.fillStyle = 'white';
        } else {
          if (grid.at(x,y)) {
            ctx.fillStyle = "rgba(235,245,255,0.8)";
          } else {
            ctx.fillStyle = "rgba(255,155,0,0.12)";
          }
        }

        ctx.fillRect((x * SQUARE_SIZE) - SQUARE_SIZE, (y * SQUARE_SIZE) - SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
        grid.set(x, y, 0);
      }

      function birth(x, y) {
        if (game.MODE === GAME_MODES.CLASSIC) {
          ctx.fillStyle = 'black';
        } else {
          ctx.fillStyle = "rgba(0,100,255,0.50)";
        }

        ctx.fillRect((x * SQUARE_SIZE) - SQUARE_SIZE, (y * SQUARE_SIZE) - SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);
        grid.set(x, y, 1);
      }


      function play() {
        game.PLAYING = !game.PLAYING;
        var currentCellCount = grid.filter(function(item) { return item;}).length;

        grid.each(function(state, coordString) {
          var coords = coordString.split('x');
          var x = +coords[0], y = +coords[1];

          neighborCount = neighbors(x,y).filter(function(coordList) {
            var xx = +coordList[0], yy = +coordList[1];

            return grid.at(xx, yy) ? true : false;
          }).length;

          if (neighborCount > 1 && neighborCount <= 3) {
            if (game.MODE === GAME_MODES.ARCADE) {
              reColor(x,y, "rgba(255, 0, 100, 0.20)");
            }

            if (neighborCount === 3) {
              shouldLive.push([x,y]);
            }
          } else if (neighborCount >= 4 || neighborCount <= 1) {
            shouldDie.push([x,y]);
          }
        });

        var toKill;
        while (shouldDie.length) {
          toKill = shouldDie.pop();

          kill(toKill[0], toKill[1]);
        }

        var toBirth;
        while (shouldLive.length) {
          toBirth = shouldLive.pop();

          birth(toBirth[0], toBirth[1]);
        }

        shouldDie.length = 0;
        shouldLive.length = 0;
        counter += 1;


        var newCellCount = grid.filter(function(item) { return item; }).length;

        if (newCellCount === currentCellCount) {
          shouldEnd++;
        } else {
          shouldEnd = 0;
        }

        if (shouldEnd >= 8) {
          alert('Game Over');
          clearInterval(gameInterval);
          return;
        }

        livingCellsEl.innerHTML = newCellCount;
        countEl.innerHTML = counter;
      }



      document.getElementById('play').onclick = function() {
        play();
        gameInterval = setInterval(play, TICK);
      }
    </script>
  </body>
</html>
